---
title: 正则表达式的基础使用，包括量词，贪婪与惰性，分支...
date: 2025-03-11
category: Note
tags:
    - JavaScript
    - Tool
description: 模糊匹配，字符组，量词，贪婪与惰性匹配，多选分支，小案例
outline: [2,4]
---

# 正则表达式

## 模糊匹配

### 横向匹配

一个正则可以匹配的字符串的 **长度不固定**，可以是多种情况

例如：`{m,n}`，表示连续出现的最少 **m 次**，最多 **n 次**。

```js
/ab{2,5}c/
```

表示匹配第一个字符是 `a`，接下来的 2 到 5 个字符是 `b`，最后是字符 `c`。

```js
const regex = /ab{2,5}c/g;
const string = "abc abbc abbbc abbbbc abbbbbc";
console.log(string.match(regex));
//  ["abbc", "abbbc", "abbbbc", "abbbbbc"]
```

> [!important]
>
> `g` 表示全局匹配，否则只匹配第一个
> 在目标字符串中按照属性找到满足匹配模式的 **所有字符串**

### 纵向匹配

在匹配具体的某一位字符时，它可以不是某一个确定的字符，可以有多种肯可能

```js
/abc/
```

表示该字符是 `a`, `b`, `c`, 中的任何一个即可

```js
const regex = /a[123]b/g;
const string = "a0b a1b a2b a3b a4b";
console.log(string.match(regex));
// (3) ["a1b", "a2b", "a3b"]
```

## 字符组

```js
[abc]	// 表示匹配一个字符，可以是 a, b, c 其中之一
```

### 范围表示法

```js
[123456abcdefgHIGKLMN]
// 可以写成
[1-6a-gH-N]
```

如果匹配 `1`, `-`, `6`, 这三个字符其中一个需要写成：

```js
[-16]
[61-]
[1\-6]	// 使用转义
```

### 排除

```js
[^abc]
```

表示某一位的字符可以是任何东西，除了 `a`, `b`, `c`.

### 简写形式

| 字符组 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| \d     | [0-9]                                                        |
| \D     | [^0-9]                                                       |
| \w     | [0-9a-zA-Z_] 数字，大小写，下划线                            |
| \W     | [^0-9a-zA-Z_]                                                |
| \s     | [ \t\v\n\r\f] 空白符，空格，水平制表符，换行符，回车符，换页符 |
| \S     | [^ \t\v\n\r\f]                                               |
| .      | [^\n\r\u2028\u2029] 通配符，表示几乎任意在字符                |

### 量词

| 量词 | 含义                       |
| ---- | -------------------------- |
|` {m,}` | 表示最少出现 **m 次**        |
| `{m}`  | 表示出现 **m 次**            |
| ？   | 表示 **出现** 或者 **不出现** |
| +    | 表示最少出现一次           |
| *    | 表示出现任意次数，包括 0 次  |

### 贪婪与惰性

```js
let regex = /\d{2,5}/g;
let string = "123 1234 12345 123456 1234567";
console.log(string.match(regex));
// (6) ["123", "1234", "12345", "12345", "12345", "67"]
```

上述正则表示数字连续出现 2 到 5 次。会匹配 2 位，3 位，4 位，5 位连续数字

其是贪婪模式，会尽可能匹配

比如给 6 个，要 5 个，给 3 个，要三个，在匹配范围内，越多越好

**惰性匹配**就是尽可能地**少匹配**

```js
let regex = /\d{2,5}?/g;
let string = "123 1234 12345 123456 1234567";
console.log(string.match(regex));
// (11) ["12", "12", "34", "12", "34", "12", "34", "56", "12", "34", "56"]
```

其中`的/\d{2,5}?/`表示，虽然2到5次都行，但是2个就够的时候就不要往下尝试了

所以，通过在量词后面加上一个**问号**`?`就能实现**惰性匹配**

| 惰性量词 | 贪婪量词 |
| -------- | -------- |
| `{m,n}?` | `{m,n}`  |
| `{m,}?`  | `{m,}`   |
| `??`     | `?`      |
| `+?`     | `+`      |
| `*?`     | `*`      |

> [!IMPORTANT]
>
> 只需理解成在量词后面加上一个**问号**

## 多选分支

一个模式可以实现**横向**和**纵向**的模糊匹配，多选分支用于支持**多个子模式其中之一**

`(p1|p2|p3)`，其中p1,p2,p3就是子模式，使用`|`管道符分割，表示**其中之一**

比如匹配字符串`student`和`teacher`，可以使用`/student|teacher/`

```js
let regex = /student|teacher/g;
let string = "student teacher person people home";
console.log(string.match(regex));
// (2) ["student", "teacher"]
```

> [!IMPORTANT]
>
> 使用`/good|goodbye/`去匹配`goodbye`的时候，结果是`good`

```js
		let regex = /good|goodbye/g;
		let string = "goodbye";
		console.log(string.match(regex));
		// ["good"]
```

```js
/goodbye|good/	// 修改后,即可匹配到goodbye
```

由此可见，**分支结构**是惰性的，即当前面的匹配上了，后面的就不再尝试了

### 案例

#### 匹配16进制颜色值

```js
#ffbbad
#Fc01DF
#FFF
#ffE
```

使用**字符组**，`[0-9a-fA-F]`

其中字符可以出现**3次**或者**6次**，使用量词和分支结构

```js
let regex = /#([0-9a-fA-F]{6})|[0-9a-fA-F]{3}/g;
let string = "#ffbbad #Fc01DF #FFF #ffE #fff #ABCDSFD";
console.log(string.match(regex));
// (6) ["#ffbbad", "#Fc01DF", "FFF", "ffE", "fff", "ABC"]
// 因为分支结构是惰性的，所以ABC也匹配到了
```

#### 匹配时间

```js
13:47
8:30
```

总共**4位**数字，第一位数字可以为`[0-2]`，即`0`,`1`,`2`

当第一位为`2`时，第二位可以为`[0-3]`，其他情况则为`[0-9]`

第三位数字为`[0-5]`，第四位为`[0-9]`
